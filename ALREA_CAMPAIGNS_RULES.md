# üìã ALREA CAMPAIGNS - Regras de Desenvolvimento

> **Projeto:** ALREA - Sistema Multi-Produto de Marketing e Analytics  
> **M√≥dulo:** Campaigns (Disparos WhatsApp)  
> **Stack:** Django 5 + DRF + Celery + PostgreSQL + React + TypeScript  
> **√öltima Atualiza√ß√£o:** 2025-10-08

---

## üìö √çNDICE

1. [Filosofia do Projeto](#filosofia-do-projeto)
2. [Arquitetura Django](#arquitetura-django)
3. [Workers e Processamento Ass√≠ncrono](#workers-e-processamento-ass√≠ncrono)
4. [M√∫ltiplas Campanhas Simult√¢neas](#m√∫ltiplas-campanhas-simult√¢neas)
5. [Sistema de Janelas e Hor√°rios](#sistema-de-janelas-e-hor√°rios)
6. [Anti-Spam e Prote√ß√µes](#anti-spam-e-prote√ß√µes)
7. [UI/UX Guidelines](#uiux-guidelines)
8. [Testes](#testes)
9. [Performance](#performance)
10. [Seguran√ßa](#seguran√ßa)
11. [Checklist de Code Review](#checklist-de-code-review)

---

## üéØ FILOSOFIA DO PROJETO

### Princ√≠pios Fundamentais

1. **UX-First Development**: Toda feature come√ßa pelo design da experi√™ncia do usu√°rio
2. **Progressive Disclosure**: Mostrar apenas o necess√°rio, esconder complexidade
3. **Feedback Instant√¢neo**: Usu√°rio NUNCA fica sem saber o que est√° acontecendo
4. **Zero Surpresas**: Sistema deve ser previs√≠vel e transparente
5. **Fail Gracefully**: Erros s√£o oportunidades para ajudar o usu√°rio

### Valores de C√≥digo

- **Expl√≠cito > Impl√≠cito**: C√≥digo deve ser √≥bvio, n√£o "esperto"
- **Test√°vel**: Se √© dif√≠cil testar, est√° mal arquitetado
- **Performance Consciente**: Otimizar pontos cr√≠ticos, n√£o tudo
- **Multi-tenant First**: SEMPRE pensar em isolamento de dados
- **Audit Everything**: Cada a√ß√£o importante deve ser logada

---

## üèóÔ∏è ARQUITETURA DJANGO

### Estrutura de Apps

```
backend/apps/
‚îú‚îÄ‚îÄ campaigns/          # Sistema de campanhas
‚îÇ   ‚îú‚îÄ‚îÄ models.py      # Campaign, CampaignMessage, CampaignContact
‚îÇ   ‚îú‚îÄ‚îÄ views.py       # ViewSets DRF
‚îÇ   ‚îú‚îÄ‚îÄ serializers.py # Serializers com valida√ß√µes ricas
‚îÇ   ‚îú‚îÄ‚îÄ tasks.py       # Celery tasks (scheduler, dispatcher)
‚îÇ   ‚îú‚îÄ‚îÄ services.py    # L√≥gica de neg√≥cio (CampaignService)
‚îÇ   ‚îú‚îÄ‚îÄ permissions.py # Permissions customizadas
‚îÇ   ‚îú‚îÄ‚îÄ validators.py  # Validadores reutiliz√°veis
‚îÇ   ‚îú‚îÄ‚îÄ signals.py     # Hooks de lifecycle
‚îÇ   ‚îî‚îÄ‚îÄ tests/         # Testes organizados por tipo
‚îÇ       ‚îú‚îÄ‚îÄ test_models.py
‚îÇ       ‚îú‚îÄ‚îÄ test_views.py
‚îÇ       ‚îú‚îÄ‚îÄ test_tasks.py
‚îÇ       ‚îî‚îÄ‚îÄ test_services.py
‚îÇ
‚îú‚îÄ‚îÄ contacts/          # Gest√£o de contatos
‚îú‚îÄ‚îÄ connections/       # Inst√¢ncias Evolution API
‚îú‚îÄ‚îÄ tenancy/           # Multi-tenancy
‚îú‚îÄ‚îÄ billing/           # Planos e pagamentos
‚îî‚îÄ‚îÄ common/            # Utilit√°rios compartilhados
```

### Regras de Models

#### ‚úÖ SEMPRE FAZER:

```python
# 1. UUIDs como Primary Key (seguran√ßa + multi-tenant)
class Campaign(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    
# 2. Tenant isolation em TODOS os models de neg√≥cio
class Campaign(models.Model):
    tenant = models.ForeignKey('tenancy.Tenant', on_delete=models.CASCADE)
    
    class Meta:
        # Sempre indexar tenant + campos de busca frequente
        indexes = [
            models.Index(fields=['tenant', 'status', 'created_at']),
        ]

# 3. Timestamps autom√°ticos
class Campaign(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
# 4. Status como Choices (nunca strings soltas)
class Campaign(models.Model):
    class Status(models.TextChoices):
        DRAFT = 'draft', 'Rascunho'
        ACTIVE = 'active', 'Ativa'
        PAUSED = 'paused', 'Pausada'
        COMPLETED = 'completed', 'Conclu√≠da'
        CANCELLED = 'cancelled', 'Cancelada'
    
    status = models.CharField(
        max_length=20,
        choices=Status.choices,
        default=Status.DRAFT,
        db_index=True  # Status √© buscado frequentemente
    )

# 5. Help text descritivo
class Campaign(models.Model):
    delay_min_seconds = models.IntegerField(
        default=20,
        help_text="Delay m√≠nimo entre envios (segundos). Recomendado: 20-30s para parecer natural."
    )

# 6. Validators no model
from django.core.validators import MinValueValidator, MaxValueValidator

class Campaign(models.Model):
    delay_min_seconds = models.IntegerField(
        validators=[MinValueValidator(10), MaxValueValidator(300)]
    )

# 7. Properties para l√≥gica derivada
class Campaign(models.Model):
    sent_messages = models.IntegerField(default=0)
    total_contacts = models.IntegerField(default=0)
    
    @property
    def progress_percentage(self):
        """Percentual de progresso da campanha"""
        if self.total_contacts == 0:
            return 0
        return round((self.sent_messages / self.total_contacts) * 100, 1)
    
    @property
    def can_be_started(self):
        """Verifica se campanha pode ser iniciada"""
        return (
            self.status == Campaign.Status.DRAFT and
            self.total_contacts > 0 and
            self.messages.filter(is_active=True).exists() and
            self.instance.is_connected
        )

# 8. Methods para a√ß√µes de neg√≥cio
class Campaign(models.Model):
    def start(self, user):
        """Inicia a campanha"""
        if not self.can_be_started:
            raise ValidationError("Campanha n√£o pode ser iniciada no estado atual")
        
        self.status = Campaign.Status.ACTIVE
        self.started_at = timezone.now()
        self.started_by = user
        self.save(update_fields=['status', 'started_at', 'started_by'])
        
        # Log de auditoria
        CampaignLog.objects.create(
            campaign=self,
            user=user,
            event_type='campaign_started',
            message=f'Campanha iniciada por {user.email}'
        )
        
        # Signal para side effects
        campaign_started.send(sender=self.__class__, campaign=self, user=user)

# 9. __str__ √∫til para debugging
def __str__(self):
    return f"{self.name} ({self.get_status_display()}) - {self.tenant.name}"

# 10. Meta ordenada e verbosa
class Meta:
    db_table = 'campaigns_campaign'
    verbose_name = 'Campanha'
    verbose_name_plural = 'Campanhas'
    ordering = ['-created_at']
    
    # Constraints de neg√≥cio no banco
    constraints = [
        models.UniqueConstraint(
            fields=['instance'],
            condition=models.Q(status='active'),
            name='unique_active_campaign_per_instance'
        ),
        models.CheckConstraint(
            check=models.Q(delay_min_seconds__lte=models.F('delay_max_seconds')),
            name='delay_min_lte_delay_max'
        ),
    ]
```

#### ‚ùå NUNCA FAZER:

```python
# ‚ùå IDs incrementais (vazam informa√ß√£o, n√£o escalam em multi-tenant)
id = models.AutoField(primary_key=True)

# ‚ùå Strings m√°gicas
status = 'active'  # Use choices!

# ‚ùå L√≥gica de neg√≥cio nos views
def create_campaign(request):
    campaign = Campaign.objects.create(...)
    # enviar email
    # criar logs
    # etc
    # ‚ùå Isso deve estar em um Service!

# ‚ùå Queries sem select_related/prefetch_related
campaigns = Campaign.objects.all()  # N+1 query problem
for c in campaigns:
    print(c.instance.name)  # 1 query por campanha!

# ‚úÖ CORRETO:
campaigns = Campaign.objects.select_related('instance', 'tenant').all()

# ‚ùå Uso de .get() sem tratamento
campaign = Campaign.objects.get(id=campaign_id)  # Pode levantar DoesNotExist

# ‚úÖ CORRETO:
from django.shortcuts import get_object_or_404
campaign = get_object_or_404(Campaign, id=campaign_id, tenant=request.tenant)
```

---

### Regras de Services

**Services encapsulam l√≥gica de neg√≥cio complexa**

```python
# campaigns/services.py

class CampaignService:
    """Service para opera√ß√µes de campanha"""
    
    def __init__(self, tenant, user=None):
        self.tenant = tenant
        self.user = user
    
    def create_campaign(self, data: dict) -> Campaign:
        """
        Cria uma nova campanha com todas as valida√ß√µes de neg√≥cio
        
        Args:
            data: Dicion√°rio com dados da campanha
            
        Returns:
            Campaign criada
            
        Raises:
            ValidationError: Se dados inv√°lidos
            PermissionDenied: Se tenant n√£o tem permiss√£o
        """
        # 1. Validar limites do plano
        if not self.tenant.can_create_campaign():
            raise PermissionDenied(
                "Limite de campanhas atingido. Fa√ßa upgrade do plano."
            )
        
        # 2. Validar inst√¢ncia dispon√≠vel
        instance = data.get('instance')
        if instance.has_active_campaign:
            raise ValidationError({
                'instance': f'Inst√¢ncia ocupada com campanha "{instance.current_campaign.name}"'
            })
        
        # 3. Criar campanha
        with transaction.atomic():
            campaign = Campaign.objects.create(
                tenant=self.tenant,
                created_by=self.user,
                **data
            )
            
            # 4. Criar relacionamentos de contatos
            contacts = data.get('contacts', [])
            campaign_contacts = [
                CampaignContact(
                    campaign=campaign,
                    contact=contact,
                    status=CampaignContact.Status.PENDING
                )
                for contact in contacts
            ]
            CampaignContact.objects.bulk_create(campaign_contacts)
            
            # 5. Atualizar contador
            campaign.total_contacts = len(contacts)
            campaign.save(update_fields=['total_contacts'])
            
            # 6. Log de auditoria
            CampaignLog.objects.create(
                campaign=campaign,
                user=self.user,
                event_type='campaign_created',
                message=f'Campanha criada com {len(contacts)} contatos',
                metadata={'contact_count': len(contacts)}
            )
        
        return campaign
    
    def start_campaign(self, campaign_id: uuid.UUID) -> Campaign:
        """Inicia campanha com todas as valida√ß√µes"""
        campaign = get_object_or_404(
            Campaign,
            id=campaign_id,
            tenant=self.tenant
        )
        
        # Valida√ß√µes
        if not campaign.can_be_started:
            raise ValidationError("Campanha n√£o pode ser iniciada")
        
        # Iniciar
        campaign.start(user=self.user)
        
        return campaign
```

**USO nos Views:**

```python
# views.py

class CampaignViewSet(viewsets.ModelViewSet):
    
    @action(detail=False, methods=['post'])
    def create_and_start(self, request):
        """Criar e iniciar campanha em uma a√ß√£o"""
        serializer = CampaignCreateSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        
        # Service encapsula a complexidade
        service = CampaignService(
            tenant=request.tenant,
            user=request.user
        )
        
        try:
            campaign = service.create_campaign(serializer.validated_data)
            campaign = service.start_campaign(campaign.id)
            
            return Response(
                CampaignSerializer(campaign).data,
                status=status.HTTP_201_CREATED
            )
        except PermissionDenied as e:
            return Response(
                {'error': 'PERMISSION_DENIED', 'message': str(e)},
                status=status.HTTP_403_FORBIDDEN
            )
        except ValidationError as e:
            return Response(
                {'error': 'VALIDATION_ERROR', 'details': e.message_dict},
                status=status.HTTP_400_BAD_REQUEST
            )
```

---

### Regras de Serializers

```python
# serializers.py

class CampaignSerializer(serializers.ModelSerializer):
    """Serializer completo de campanha"""
    
    # Campos derivados (read-only)
    progress_percentage = serializers.ReadOnlyField()
    can_be_started = serializers.ReadOnlyField()
    
    # Relacionamentos nested (apenas leitura)
    instance = EvolutionInstanceSerializer(read_only=True)
    messages = CampaignMessageSerializer(many=True, read_only=True)
    
    # Campos write-only para cria√ß√£o
    instance_id = serializers.UUIDField(write_only=True)
    contact_ids = serializers.ListField(
        child=serializers.UUIDField(),
        write_only=True,
        required=False
    )
    
    class Meta:
        model = Campaign
        fields = [
            'id', 'name', 'status', 'progress_percentage',
            'instance', 'instance_id',
            'messages', 'contact_ids',
            'total_contacts', 'sent_messages', 'failed_messages',
            'can_be_started',
            'created_at', 'updated_at'
        ]
        read_only_fields = ['id', 'status', 'sent_messages', 'failed_messages']
    
    def validate_instance_id(self, value):
        """Valida que inst√¢ncia existe e est√° dispon√≠vel"""
        try:
            instance = EvolutionInstance.objects.get(
                id=value,
                tenant=self.context['request'].tenant
            )
        except EvolutionInstance.DoesNotExist:
            raise serializers.ValidationError("Inst√¢ncia n√£o encontrada")
        
        if not instance.is_connected:
            raise serializers.ValidationError(
                "Inst√¢ncia est√° desconectada. Conecte-a antes de criar a campanha."
            )
        
        if instance.has_active_campaign:
            raise serializers.ValidationError(
                f'Inst√¢ncia ocupada com a campanha "{instance.current_campaign.name}"'
            )
        
        return value
    
    def validate_contact_ids(self, value):
        """Valida que contatos existem e pertencem ao tenant"""
        if not value:
            return value
        
        contacts = Contact.objects.filter(
            id__in=value,
            tenant=self.context['request'].tenant
        )
        
        if contacts.count() != len(value):
            raise serializers.ValidationError(
                "Um ou mais contatos n√£o foram encontrados"
            )
        
        return value
    
    def validate(self, attrs):
        """Valida√ß√µes cross-field"""
        # Exemplo: se selecionou tag, n√£o pode enviar contact_ids
        if attrs.get('contact_tag') and attrs.get('contact_ids'):
            raise serializers.ValidationError(
                "Selecione apenas tag OU lista de contatos, n√£o ambos"
            )
        
        return attrs
```

---

### Regras de Celery Tasks

```python
# tasks.py

from celery import shared_task
from celery.utils.log import get_task_logger

logger = get_task_logger(__name__)

@shared_task(
    bind=True,
    max_retries=3,
    soft_time_limit=60,  # 60s timeout
    time_limit=90,        # 90s hard limit
    autoretry_for=(ConnectionError, TimeoutError),
    retry_backoff=True,
    retry_backoff_max=600,
    retry_jitter=True
)
def send_message_task(self, campaign_id, contact_relation_id, message_id, rendered_message):
    """
    Envia uma mensagem via Evolution API
    
    Args:
        campaign_id: UUID da campanha
        contact_relation_id: UUID do CampaignContact
        message_id: UUID da CampaignMessage
        rendered_message: Mensagem renderizada com vari√°veis
    
    Returns:
        dict com resultado do envio
    """
    try:
        # 1. Buscar objetos (select_related para performance)
        campaign = Campaign.objects.select_related(
            'instance', 'tenant'
        ).get(id=campaign_id)
        
        contact_relation = CampaignContact.objects.select_related(
            'contact'
        ).get(id=contact_relation_id)
        
        contact = contact_relation.contact
        
        # 2. Valida√ß√µes cr√≠ticas antes de enviar
        if campaign.is_paused:
            logger.warning(
                f"Campaign {campaign_id} is paused, aborting send",
                extra={'campaign_id': str(campaign_id)}
            )
            return {'status': 'aborted', 'reason': 'paused'}
        
        if campaign.status != Campaign.Status.ACTIVE:
            logger.warning(
                f"Campaign {campaign_id} is not active (status={campaign.status})",
                extra={'campaign_id': str(campaign_id), 'status': campaign.status}
            )
            return {'status': 'aborted', 'reason': 'not_active'}
        
        # 3. Enviar via Evolution API
        logger.info(
            f"Sending message to {contact.name} ({contact.phone})",
            extra={
                'campaign_id': str(campaign_id),
                'contact_id': str(contact.id),
                'instance': campaign.instance.name
            }
        )
        
        response = evolution_api.send_text(
            instance_id=campaign.instance.evolution_instance_id,
            phone=contact.phone,
            message=rendered_message,
            api_key=campaign.instance.api_key
        )
        
        # 4. Atualizar status (usar update para evitar race conditions)
        CampaignContact.objects.filter(id=contact_relation_id).update(
            status=CampaignContact.Status.SENT,
            sent_at=timezone.now(),
            evolution_message_id=response.get('key', {}).get('id')
        )
        
        # 5. Incrementar contadores (F() expressions para atomicidade)
        Campaign.objects.filter(id=campaign_id).update(
            sent_messages=models.F('sent_messages') + 1,
            last_successful_send=timezone.now()
        )
        
        # 6. Log de sucesso
        CampaignLog.objects.create(
            campaign=campaign,
            contact=contact,
            level=CampaignLog.Level.SUCCESS,
            event_type='message_sent',
            message=f'Mensagem enviada para {contact.name}',
            metadata={
                'evolution_response': response,
                'message_length': len(rendered_message)
            }
        )
        
        logger.info(
            f"Message sent successfully to {contact.name}",
            extra={'campaign_id': str(campaign_id), 'contact_id': str(contact.id)}
        )
        
        return {'status': 'success', 'message_id': response.get('key', {}).get('id')}
        
    except Campaign.DoesNotExist:
        logger.error(f"Campaign {campaign_id} not found")
        return {'status': 'error', 'reason': 'campaign_not_found'}
        
    except Exception as e:
        logger.exception(
            f"Error sending message: {str(e)}",
            extra={'campaign_id': str(campaign_id), 'error': str(e)}
        )
        
        # Marcar como falha no banco
        CampaignContact.objects.filter(id=contact_relation_id).update(
            status=CampaignContact.Status.FAILED,
            error_message=str(e)
        )
        
        Campaign.objects.filter(id=campaign_id).update(
            failed_messages=models.F('failed_messages') + 1,
            last_error=str(e),
            last_error_at=timezone.now()
        )
        
        # Retry se for erro tempor√°rio
        if isinstance(e, (ConnectionError, TimeoutError)):
            raise self.retry(exc=e, countdown=30)
        
        raise
```

---

## ‚öôÔ∏è WORKERS E PROCESSAMENTO ASS√çNCRONO

### O que s√£o Workers?

**Workers N√ÉO s√£o backends separados.** S√£o processos Celery que rodam dentro do mesmo backend Django.

### Arquitetura de Processos

```
BACKEND (Django)
‚îú‚îÄ‚îÄ Processo 1: Django Web (Gunicorn)
‚îÇ   ‚îî‚îÄ‚îÄ Recebe requests HTTP, retorna API REST
‚îÇ       ‚ùå N√ÉO envia mensagens diretamente
‚îÇ
‚îú‚îÄ‚îÄ Processo 2: Celery Beat (Scheduler)
‚îÇ   ‚îî‚îÄ‚îÄ Roda a cada 10s, busca campanhas prontas
‚îÇ       ‚ùå N√ÉO envia mensagens
‚îÇ       ‚úÖ Enfileira tasks no Redis
‚îÇ
‚îî‚îÄ‚îÄ Processos 3-N: Celery Workers (Dispatchers)
    ‚îî‚îÄ‚îÄ ‚≠ê AQUI que as mensagens s√£o ENVIADAS
        ‚úÖ Pega tasks da fila Redis
        ‚úÖ Envia via WhatsApp Gateway API
        ‚úÖ Atualiza banco de dados
```

### Fluxo Completo de Envio

```python
# 1. Frontend ‚Üí Django API
POST /api/campaigns/123/start/
  ‚Üì Django atualiza: status='active', next_scheduled_send=NOW()+10s
  ‚Üì Retorna 200 OK
  ‚ùå NENHUMA mensagem enviada ainda

# 2. Celery Beat (10s depois)
@shared_task  # Roda a cada 10s
def campaign_scheduler():
    campaigns = Campaign.objects.filter(
        status='active',
        is_paused=False,
        next_scheduled_send__lte=NOW()
    )
    
    for campaign in campaigns:
        # Pega pr√≥ximo contato
        contact = get_next_contact(campaign)
        
        # ‚ùå N√ÉO envia aqui
        # ‚úÖ Enfileira task
        send_message_task.apply_async(
            kwargs={'campaign_id': ..., 'contact_id': ...}
        )
        # Task vai para Redis

# 3. Celery Worker (pega da fila)
@shared_task
def send_message_task(campaign_id, contact_id, message):
    # Buscar dados
    campaign = Campaign.objects.get(id=campaign_id)
    
    # Validar
    if campaign.is_paused:
        return 'aborted'
    
    # ‚≠ê ENVIAR (comunica√ß√£o real com WhatsApp)
    response = whatsapp_gateway.send_message(
        instance=campaign.instance,
        phone=contact.phone,
        message=message
    )
    
    # Atualizar banco
    CampaignContact.objects.update(status='sent')
    
    return 'success'
```

### Escalabilidade com Workers

```bash
# 1 worker = ~20 msgs/minuto
celery -A alrea_sense worker -c 1

# 3 workers = ~60 msgs/minuto
celery -A alrea_sense worker -c 3

# 10 workers = ~200 msgs/minuto
celery -A alrea_sense worker -c 10

# ‚≠ê "Adicionar workers" = aumentar concurrency (-c)
# Mais workers = mais throughput
```

### Configura√ß√£o em Produ√ß√£o

```yaml
# docker-compose.yml

services:
  # Django API
  web:
    command: gunicorn alrea_sense.wsgi:application --workers 4
  
  # Celery Beat (apenas 1 inst√¢ncia)
  celery-beat:
    command: celery -A alrea_sense beat -l info
  
  # Celery Workers (escal√°vel)
  celery-worker:
    command: celery -A alrea_sense worker -c 10 -l info
    # Escalar: docker-compose up --scale celery-worker=5
```

### Regras de Workers

```python
# ‚úÖ SEMPRE FAZER

# 1. Validar estado ANTES de enviar (worker pode pegar task antiga)
@shared_task
def send_message_task(self, campaign_id, ...):
    campaign = Campaign.objects.get(id=campaign_id)  # Fresh do banco
    
    if campaign.is_paused:  # Dupla valida√ß√£o
        return 'aborted'
    
    # S√≥ envia se passou valida√ß√£o

# 2. Usar retry autom√°tico para erros tempor√°rios
@shared_task(
    autoretry_for=(ConnectionError, TimeoutError),
    retry_backoff=True,
    max_retries=3
)
def send_message_task(self, ...):
    # ...

# 3. Liberar locks em finally
try:
    # enviar mensagem
    pass
finally:
    redis.delete(f'lock:{phone}')  # SEMPRE libera

# ‚ùå NUNCA FAZER

# 1. Enviar mensagem no endpoint da API
@action(detail=True, methods=['post'])
def start(self, request, pk=None):
    campaign.status = 'active'
    campaign.save()
    
    # ‚ùå NUNCA fazer isso:
    # for contact in contacts:
    #     send_message(contact)  # Bloqueia request!
    
    return Response({'status': 'started'})

# 2. Processar no scheduler
@shared_task
def campaign_scheduler():
    # ‚ùå NUNCA:
    # send_message(...)  # Bloqueia outros schedulers
    
    # ‚úÖ CORRETO:
    send_message_task.apply_async(...)  # Enfileira
```

---

## üîÑ M√öLTIPLAS CAMPANHAS SIMULT√ÇNEAS

### Regras de Neg√≥cio

```
‚úÖ 1 inst√¢ncia WhatsApp = 1 campanha ativa por vez
‚úÖ Cliente pode ter N campanhas ativas (limitado por inst√¢ncias)
‚úÖ Mesmo contato pode estar em m√∫ltiplas campanhas
```

### Separa√ß√£o no Banco de Dados

```python
# Cada campanha totalmente isolada por campaign_id

# Campanha A: Black Friday
Campaign(id='uuid-A', name='Black Friday', instance=inst1, status='active')
CampaignContact(campaign='uuid-A', contact='joao', status='pending')

# Campanha B: Natal (pode ter Jo√£o tamb√©m)
Campaign(id='uuid-B', name='Natal', instance=inst2, status='active')
CampaignContact(campaign='uuid-B', contact='joao', status='pending')

# ‚úÖ Constraint: UNIQUE(campaign_id, contact_id)
# ‚úÖ Jo√£o pode estar em ambas
# ‚ùå Jo√£o n√£o pode estar 2x na mesma campanha
```

### Processamento Simult√¢neo

```python
@shared_task
def campaign_scheduler():
    """Processa TODAS as campanhas prontas"""
    
    ready_campaigns = Campaign.objects.filter(
        status='active',
        is_paused=False,
        next_scheduled_send__lte=NOW()
    )
    
    # LOOP: Cada campanha independente
    for campaign in ready_campaigns:
        try:
            process_single_campaign(campaign)
        except Exception as e:
            # ‚≠ê Erro em 1 campanha N√ÉO afeta outras
            logger.exception(f"Erro em {campaign.name}")
            continue  # Pr√≥xima campanha
```

### Pausar Uma Campanha

```python
# Pausar Campanha B

Campaign.objects.filter(id='uuid-B').update(is_paused=True)

# Pr√≥ximo scheduler:
ready = Campaign.objects.filter(
    status='active',
    is_paused=False,  # ‚≠ê Campanha B n√£o aparece
    next_scheduled_send__lte=NOW()
)
# Resultado: [Campanha A, Campanha C]
# ‚úÖ Apenas B pausada, A e C continuam
```

### Performance com M√∫ltiplas Campanhas

```sql
-- √çndice otimizado para scheduler
CREATE INDEX idx_campaign_scheduler ON campaigns(
    status, is_paused, next_scheduled_send
);

-- Query do scheduler (10 campanhas ativas)
SELECT * FROM campaigns 
WHERE status='active' 
  AND is_paused=FALSE 
  AND next_scheduled_send <= NOW();
  
-- Execution time: ~5ms ‚úÖ (com √≠ndice)
```

---

## üõ°Ô∏è ANTI-SPAM E PROTE√á√ïES

### Problema: Mesmo Contato em M√∫ltiplas Campanhas

```
Jo√£o est√° em 3 campanhas ativas:
- Black Friday
- Natal
- Ano Novo

Sem prote√ß√£o: Pode receber 3 mensagens ao mesmo tempo!
```

### Solu√ß√£o: Lock por Telefone (Redis)

```python
@shared_task
def send_message_task(self, campaign_id, contact_relation_id, ...):
    
    contact = get_contact(contact_relation_id)
    
    # ‚≠ê Tentar adquirir lock no n√∫mero
    lock_key = f'phone_lock:{contact.phone}'
    lock_acquired = redis.set(
        lock_key,
        campaign_id,
        nx=True,  # S√≥ seta se N√ÉO existir
        ex=60     # Expira em 60s
    )
    
    if not lock_acquired:
        # ‚≠ê Outro worker est√° usando este n√∫mero AGORA
        logger.warning(f"N√∫mero {contact.phone} em uso, aguardando 20s")
        
        # Reagendar para 20s depois
        send_message_task.apply_async(
            kwargs={...},
            countdown=20
        )
        
        return 'deferred'
    
    # ‚úÖ Lock adquirido, pode enviar
    try:
        send_message(contact.phone, message)
    finally:
        # ‚≠ê SEMPRE liberar lock
        redis.delete(lock_key)
```

### Timeline com Lock

```
T=0s
  Worker 1 (Campanha A): Tenta lock +5511999999999
    ‚Üí SET phone_lock:+5511999 = "camp-A" NX
    ‚Üí ‚úÖ Sucesso! Envia mensagem
    
  Worker 2 (Campanha B): Tenta lock +5511999999999
    ‚Üí SET phone_lock:+5511999 = "camp-B" NX
    ‚Üí ‚ùå Falhou! Lock j√° existe
    ‚Üí Reagenda para T=20s

T=3s
  Worker 1 finaliza
    ‚Üí DELETE phone_lock:+5511999
    ‚Üí üîì Lock liberado

T=20s
  Worker 2 (retry): Tenta lock novamente
    ‚Üí SET phone_lock:+5511999 = "camp-B" NX
    ‚Üí ‚úÖ Sucesso! Envia mensagem

Resultado: 20 segundos entre mensagens ‚úÖ
```

### Regras de Lock

```python
# ‚úÖ SEMPRE

# 1. Lock com TTL (expira automaticamente)
redis.set(key, value, nx=True, ex=60)  # 60s TTL

# 2. Liberar em finally
try:
    send_message()
finally:
    redis.delete(lock_key)  # Mesmo se der erro

# 3. Reagendar se bloqueado
if not lock_acquired:
    task.apply_async(countdown=20)  # Retry

# ‚ùå NUNCA

# 1. Lock sem TTL
redis.set(key, value, nx=True)  # ‚ùå Se crashar, trava forever

# 2. N√£o liberar lock
send_message()
# ‚ùå Lock nunca √© liberado

# 3. Bloquear aguardando lock
while not redis.set(...):  # ‚ùå Trava worker
    time.sleep(1)
```

---

## üïê SISTEMA DE JANELAS E HOR√ÅRIOS

### Tipos de Agendamento

```python
class Campaign(models.Model):
    class ScheduleType(models.TextChoices):
        IMMEDIATE = 'immediate', 'Imediato'
        BUSINESS_DAYS = 'business_days', 'Apenas Dias √öteis'
        BUSINESS_HOURS = 'business_hours', 'Hor√°rio Comercial'
        CUSTOM_PERIOD = 'custom_period', 'Per√≠odo Personalizado'
```

### Valida√ß√µes Combinadas

```python
def is_allowed_to_send(campaign, current_datetime):
    """
    Valida M√öLTIPLAS condi√ß√µes simultaneamente:
    1. Dia da semana (√∫til ou n√£o)
    2. Feriado
    3. Hor√°rio do dia
    
    TODAS as condi√ß√µes ativas devem passar!
    """
    hour = current_datetime.hour
    weekday = current_datetime.weekday()  # 0=seg, 6=dom
    today = current_datetime.date()
    
    # TIPO: BUSINESS_DAYS (dias √∫teis 9h-18h)
    if campaign.schedule_type == 'business_days':
        
        # ‚≠ê CONDI√á√ÉO 1: Dia √∫til
        if weekday >= 5:  # S√°bado ou Domingo
            return False, "fim_de_semana"
        
        # ‚≠ê CONDI√á√ÉO 2: N√£o √© feriado
        if Holiday.is_holiday(today):
            return False, "feriado"
        
        # ‚≠ê CONDI√á√ÉO 3: Hor√°rio comercial
        if not (9 <= hour < 18):
            return False, "fora_horario"
        
        # ‚úÖ Todas passaram
        return True, "OK"
    
    # TIPO: CUSTOM_PERIOD (janelas personalizadas)
    if campaign.schedule_type == 'custom_period':
        
        # ‚≠ê CONDI√á√ÉO 1: Fim de semana (se configurado)
        if campaign.skip_weekends and weekday >= 5:
            return False, "fim_de_semana"
        
        # ‚≠ê CONDI√á√ÉO 2: Feriado (se configurado)
        if campaign.skip_holidays and Holiday.is_holiday(today):
            return False, "feriado"
        
        # ‚≠ê CONDI√á√ÉO 3: Janela manh√£ OU tarde
        current_time = current_datetime.time()
        
        in_morning = (
            campaign.morning_start <= current_time < campaign.morning_end
        )
        in_afternoon = (
            campaign.afternoon_start <= current_time < campaign.afternoon_end
        )
        
        if not (in_morning or in_afternoon):
            return False, "fora_janela"
        
        # ‚úÖ Todas passaram
        return True, "OK"
```

### Retomada Autom√°tica

```python
def calculate_next_send_time(campaign, current_datetime):
    """
    Calcula pr√≥xima janela v√°lida
    
    Exemplo: Sexta 18h ‚Üí Segunda 9h
    """
    
    # Se pode enviar agora, apenas delay normal
    can_send, reason = is_allowed_to_send(campaign, current_datetime)
    if can_send:
        return current_datetime + timedelta(seconds=random(20, 50))
    
    # ‚≠ê Fora da janela, buscar pr√≥ximo dia/hor√°rio v√°lido
    
    # 1. Busca pr√≥ximo dia v√°lido
    next_day = current_datetime.date() + timedelta(days=1)
    
    for attempt in range(30):  # M√°ximo 30 dias
        weekday = next_day.weekday()
        
        # Pula fim de semana?
        if campaign.skip_weekends and weekday >= 5:
            next_day += timedelta(days=1)
            continue
        
        # Pula feriado?
        if campaign.skip_holidays and Holiday.is_holiday(next_day):
            next_day += timedelta(days=1)
            continue
        
        # ‚úÖ Dia v√°lido encontrado
        break
    
    # 2. Hor√°rio de in√≠cio
    start_hour = campaign.morning_start or time(9, 0)
    
    # 3. Combina data + hora
    next_send = datetime.combine(next_day, start_hour)
    
    return make_aware(next_send)
```

### Exemplo: Sexta 17h ‚Üí Segunda 9h

```
SEXTA 17:45 - Enviando normalmente
  ‚Üì is_allowed_to_send(sexta 17:45) ‚Üí True
  ‚úÖ Envia mensagem #450

SEXTA 18:00 - Janela fechou
  ‚Üì is_allowed_to_send(sexta 18:00) ‚Üí False (hour >= 18)
  ‚Üì calculate_next_send_time(sexta 18:00)
    ‚îú‚îÄ Busca pr√≥ximo dia:
    ‚îÇ   S√°bado ‚Üí ‚ùå Fim de semana (pula)
    ‚îÇ   Domingo ‚Üí ‚ùå Fim de semana (pula)
    ‚îÇ   Segunda ‚Üí ‚úÖ Dia √∫til
    ‚îî‚îÄ Retorna: Segunda 09:00
  ‚Üì UPDATE next_scheduled_send = Segunda 09:00

S√ÅBADO/DOMINGO - Scheduler roda mas:
  ‚Üì WHERE next_scheduled_send <= NOW()
  ‚ùå Campanha n√£o aparece (next_send = Segunda 09:00)

SEGUNDA 09:00 - Retoma automaticamente
  ‚Üì WHERE next_scheduled_send <= NOW()
  ‚úÖ Campanha aparece!
  ‚Üì is_allowed_to_send(segunda 09:00) ‚Üí True
  ‚úÖ Retoma do contato #451 (onde parou)
```

### Regras de Janelas

```python
# ‚úÖ SEMPRE

# 1. Validar antes de enfileirar (scheduler)
if is_allowed_to_send(campaign, now):
    enqueue_task(...)
else:
    next_time = calculate_next_send_time(campaign, now)
    campaign.next_scheduled_send = next_time
    campaign.save()

# 2. Calcular pr√≥xima janela v√°lida (n√£o apenas +1 dia)
def calculate_next_send_time(...):
    # Loop at√© encontrar dia v√°lido
    while True:
        if is_valid_day(next_day):
            break
        next_day += timedelta(days=1)

# 3. Sempre combinar data + hora
next_send = datetime.combine(next_day, start_hour)
next_send = make_aware(next_send)  # Timezone

# ‚ùå NUNCA

# 1. Apenas pausar campanha (perde estado)
if not is_allowed_to_send(...):
    campaign.is_paused = True  # ‚ùå Perde controle

# 2. Calcular pr√≥ximo hor√°rio sem validar dia
next_send = now + timedelta(hours=15)  # ‚ùå Pode cair em feriado

# 3. Ignorar timezone
next_send = datetime.combine(...)  # ‚ùå Naive datetime
```

### Configura√ß√£o de Feriados

```python
class Holiday(models.Model):
    date = models.DateField()
    name = models.CharField(max_length=200)
    is_national = models.BooleanField(default=False)
    tenant = models.ForeignKey(Tenant, null=True)  # null = nacional
    
    @classmethod
    def is_holiday(cls, date, tenant=None):
        query = Q(date=date, is_active=True)
        
        if tenant:
            # Feriados nacionais OU do tenant
            query &= (Q(tenant=tenant) | Q(is_national=True, tenant__isnull=True))
        else:
            query &= Q(is_national=True)
        
        return cls.objects.filter(query).exists()

# Seed inicial
Holiday.objects.bulk_create([
    Holiday(date='2025-01-01', name='Ano Novo', is_national=True),
    Holiday(date='2025-04-21', name='Tiradentes', is_national=True),
    Holiday(date='2025-12-25', name='Natal', is_national=True),
])
```

---

## üé® UI/UX GUIDELINES

### Princ√≠pios de Design

#### 1. **Feedback Imediato**

```typescript
// ‚ùå MAU: Sem feedback
const handleStart = async () => {
  await api.startCampaign(id);
}

// ‚úÖ BOM: Feedback visual
const handleStart = async () => {
  setIsStarting(true);
  try {
    await api.startCampaign(id);
    toast.success('Campanha iniciada com sucesso!');
  } catch (error) {
    toast.error(error.message);
  } finally {
    setIsStarting(false);
  }
}

// ‚úÖ MELHOR: Loading states espec√≠ficos
const handleStart = async () => {
  setButtonState('starting'); // Bot√£o mostra "Iniciando..."
  
  try {
    await api.startCampaign(id);
    setButtonState('started'); // Mostra checkmark por 2s
    setTimeout(() => setButtonState('active'), 2000);
    toast.success('Campanha iniciada!');
  } catch (error) {
    setButtonState('error'); // Mostra erro no bot√£o
    setTimeout(() => setButtonState('idle'), 3000);
    toast.error(error.message);
  }
}
```

#### 2. **Estados Vazios Amig√°veis**

```tsx
// ‚úÖ Empty states construtivos
{campaigns.length === 0 ? (
  <EmptyState
    icon={<MegaphoneIcon />}
    title="Nenhuma campanha criada"
    description="Campanhas permitem enviar mensagens em massa para seus contatos"
    action={{
      label: "Criar Primeira Campanha",
      onClick: () => navigate('/campaigns/new')
    }}
    helpLink={{
      label: "Como funcionam as campanhas?",
      href: "/docs/campaigns"
    }}
  />
) : (
  <CampaignList campaigns={campaigns} />
)}
```

#### 3. **Valida√ß√£o Progressiva**

```tsx
// ‚úÖ Validar enquanto usu√°rio digita
const [name, setName] = useState('');
const [nameError, setNameError] = useState('');

const validateName = (value: string) => {
  if (value.length === 0) {
    setNameError('');
  } else if (value.length < 3) {
    setNameError('Nome muito curto (m√≠nimo 3 caracteres)');
  } else if (value.length > 100) {
    setNameError('Nome muito longo (m√°ximo 100 caracteres)');
  } else {
    setNameError('');
  }
}

<Input
  label="Nome da Campanha"
  value={name}
  onChange={(e) => {
    setName(e.target.value);
    validateName(e.target.value);
  }}
  error={nameError}
  helperText={nameError || `${name.length}/100 caracteres`}
  success={name.length >= 3 && !nameError}
/>
```

#### 4. **Preview em Tempo Real**

```tsx
// ‚úÖ Mostrar preview de mensagens com vari√°veis
<MessageEditor
  value={messageText}
  onChange={setMessageText}
  variables={['nome', 'quem_indicou', 'saudacao']}
  renderPreview={(text) => (
    <MessagePreview
      text={text}
      sampleContact={{
        nome: 'Jo√£o Silva',
        quem_indicou: 'Maria Santos'
      }}
      currentTime={new Date()}
    />
  )}
/>

// Resultado visual:
// Editor: "{{saudacao}}, {{nome}}! Vi que {{quem_indicou}} te indicou..."
// Preview: "Bom dia, Jo√£o Silva! Vi que Maria Santos te indicou..."
```

#### 5. **Confirma√ß√µes Contextuais**

```tsx
// ‚úÖ Confirma√ß√£o com contexto
<ConfirmDialog
  open={showCancelDialog}
  title="Encerrar Campanha?"
  description={`
    A campanha "${campaign.name}" ser√° cancelada.
    ${campaign.sent_messages} de ${campaign.total_contacts} mensagens foram enviadas.
    ${campaign.total_contacts - campaign.sent_messages} contatos N√ÉO receber√£o mensagens.
  `}
  severity="warning"
  confirmText="Sim, Encerrar"
  cancelText="Continuar Campanha"
  onConfirm={handleCancel}
  onClose={() => setShowCancelDialog(false)}
/>
```

#### 6. **Loading States Espec√≠ficos**

```tsx
// ‚ùå Loading gen√©rico
{isLoading && <Spinner />}

// ‚úÖ Loading espec√≠fico com skeleton
{isLoading ? (
  <CampaignCardSkeleton count={3} />
) : (
  campaigns.map(c => <CampaignCard campaign={c} />)
)}

// ‚úÖ Loading inline
<Button loading={isSaving}>
  {isSaving ? 'Salvando...' : 'Salvar Campanha'}
</Button>
```

#### 7. **Cores Sem√¢nticas Consistentes**

```css
/* tailwind.config.js - Extend colors */
colors: {
  // Estados de campanha
  campaign: {
    draft: '#9CA3AF',      // Gray
    active: '#10B981',     // Green
    paused: '#F59E0B',     // Amber
    completed: '#3B82F6',  // Blue
    cancelled: '#EF4444',  // Red
  },
  
  // Feedback
  success: '#10B981',
  warning: '#F59E0B',
  error: '#EF4444',
  info: '#3B82F6',
  
  // Actions
  primary: '#6366F1',    // Indigo
  secondary: '#8B5CF6',  // Purple
}
```

---

### Components Pattern

```tsx
// ‚úÖ Componente bem estruturado

interface CampaignCardProps {
  campaign: Campaign;
  onStart?: (id: string) => void;
  onPause?: (id: string) => void;
  onCancel?: (id: string) => void;
  onViewDetails?: (id: string) => void;
}

export function CampaignCard({
  campaign,
  onStart,
  onPause,
  onCancel,
  onViewDetails
}: CampaignCardProps) {
  // 1. Estados locais
  const [isActionLoading, setIsActionLoading] = useState(false);
  
  // 2. L√≥gica derivada
  const statusColor = {
    draft: 'bg-gray-100 text-gray-800',
    active: 'bg-green-100 text-green-800',
    paused: 'bg-amber-100 text-amber-800',
    completed: 'bg-blue-100 text-blue-800',
    cancelled: 'bg-red-100 text-red-800',
  }[campaign.status];
  
  const canStart = campaign.status === 'draft' && campaign.can_be_started;
  const canPause = campaign.status === 'active';
  const canResume = campaign.status === 'paused';
  
  // 3. Handlers
  const handleAction = async (action: () => Promise<void>) => {
    setIsActionLoading(true);
    try {
      await action();
    } finally {
      setIsActionLoading(false);
    }
  };
  
  // 4. Render
  return (
    <Card className="hover:shadow-lg transition-shadow">
      <CardHeader>
        <div className="flex items-start justify-between">
          <div>
            <h3 className="text-lg font-semibold">{campaign.name}</h3>
            <Badge className={statusColor}>
              {campaign.status_display}
            </Badge>
          </div>
          
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <IconButton icon={<EllipsisVerticalIcon />} />
            </DropdownMenuTrigger>
            <DropdownMenuContent>
              <DropdownMenuItem onClick={() => onViewDetails?.(campaign.id)}>
                Ver Detalhes
              </DropdownMenuItem>
              {/* Mais op√ß√µes... */}
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </CardHeader>
      
      <CardContent>
        {/* Progress bar */}
        <ProgressBar 
          value={campaign.progress_percentage} 
          label={`${campaign.sent_messages} / ${campaign.total_contacts}`}
        />
        
        {/* Stats */}
        <div className="grid grid-cols-3 gap-4 mt-4">
          <Stat 
            label="Enviadas" 
            value={campaign.sent_messages}
            icon={<CheckIcon className="text-green-500" />}
          />
          <Stat 
            label="Respondidas" 
            value={campaign.responded_count}
            subtitle={`${campaign.response_rate}%`}
            icon={<ChatBubbleIcon className="text-blue-500" />}
          />
          <Stat 
            label="Falhas" 
            value={campaign.failed_messages}
            icon={<XMarkIcon className="text-red-500" />}
          />
        </div>
      </CardContent>
      
      <CardFooter>
        <div className="flex gap-2 w-full">
          {canStart && (
            <Button 
              onClick={() => handleAction(() => onStart!(campaign.id))}
              loading={isActionLoading}
              className="flex-1"
            >
              <PlayIcon className="w-4 h-4 mr-2" />
              Iniciar
            </Button>
          )}
          
          {canPause && (
            <Button
              variant="warning"
              onClick={() => handleAction(() => onPause!(campaign.id))}
              loading={isActionLoading}
            >
              <PauseIcon className="w-4 h-4 mr-2" />
              Pausar
            </Button>
          )}
          
          {canResume && (
            <Button
              variant="success"
              onClick={() => handleAction(() => onStart!(campaign.id))}
              loading={isActionLoading}
              className="flex-1"
            >
              <PlayIcon className="w-4 h-4 mr-2" />
              Retomar
            </Button>
          )}
        </div>
      </CardFooter>
    </Card>
  );
}
```

---

## üß™ TESTES

### Testes de Models

```python
# tests/test_models.py

class CampaignModelTest(TestCase):
    
    def setUp(self):
        self.tenant = Tenant.objects.create(name="Test Tenant")
        self.instance = EvolutionInstance.objects.create(
            tenant=self.tenant,
            name="Test Instance",
            is_connected=True
        )
        self.campaign = Campaign.objects.create(
            tenant=self.tenant,
            name="Test Campaign",
            instance=self.instance
        )
    
    def test_campaign_creation(self):
        """Testa cria√ß√£o de campanha"""
        self.assertEqual(self.campaign.status, Campaign.Status.DRAFT)
        self.assertEqual(self.campaign.sent_messages, 0)
        self.assertIsNotNone(self.campaign.id)
    
    def test_progress_percentage(self):
        """Testa c√°lculo de progresso"""
        self.campaign.total_contacts = 100
        self.campaign.sent_messages = 50
        self.assertEqual(self.campaign.progress_percentage, 50.0)
    
    def test_can_be_started_requires_contacts(self):
        """Campanha n√£o pode iniciar sem contatos"""
        self.assertFalse(self.campaign.can_be_started)
        
        # Adicionar contatos
        contact = Contact.objects.create(
            tenant=self.tenant,
            name="Test",
            phone="5511999999999"
        )
        CampaignContact.objects.create(
            campaign=self.campaign,
            contact=contact
        )
        self.campaign.total_contacts = 1
        
        # Ainda falta mensagem
        self.assertFalse(self.campaign.can_be_started)
        
        # Adicionar mensagem
        CampaignMessage.objects.create(
            campaign=self.campaign,
            message_text="Test message"
        )
        
        # Agora pode iniciar
        self.assertTrue(self.campaign.can_be_started)
    
    def test_unique_active_campaign_per_instance(self):
        """S√≥ pode ter 1 campanha ativa por inst√¢ncia"""
        self.campaign.status = Campaign.Status.ACTIVE
        self.campaign.save()
        
        # Tentar criar outra campanha ativa na mesma inst√¢ncia
        with self.assertRaises(IntegrityError):
            Campaign.objects.create(
                tenant=self.tenant,
                name="Another Campaign",
                instance=self.instance,
                status=Campaign.Status.ACTIVE
            )
```

### Testes de API

```python
# tests/test_views.py

class CampaignAPITest(APITestCase):
    
    def setUp(self):
        self.user = User.objects.create_user(
            email='test@example.com',
            password='testpass123'
        )
        self.tenant = Tenant.objects.create(name="Test Tenant")
        self.user.tenant = self.tenant
        self.user.save()
        
        self.client.force_authenticate(user=self.user)
    
    def test_list_campaigns(self):
        """Testa listagem de campanhas"""
        Campaign.objects.create(
            tenant=self.tenant,
            name="Campaign 1",
            instance=self.instance
        )
        
        response = self.client.get('/api/campaigns/')
        
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data), 1)
        self.assertEqual(response.data[0]['name'], "Campaign 1")
    
    def test_create_campaign(self):
        """Testa cria√ß√£o de campanha"""
        data = {
            'name': 'New Campaign',
            'instance_id': str(self.instance.id),
            'contact_ids': [str(self.contact.id)]
        }
        
        response = self.client.post('/api/campaigns/', data, format='json')
        
        self.assertEqual(response.status_code, 201)
        self.assertEqual(Campaign.objects.count(), 1)
    
    def test_start_campaign_validation(self):
        """Testa que campanha sem mensagens n√£o pode iniciar"""
        campaign = Campaign.objects.create(
            tenant=self.tenant,
            name="Test",
            instance=self.instance,
            total_contacts=1
        )
        
        response = self.client.post(f'/api/campaigns/{campaign.id}/start/')
        
        self.assertEqual(response.status_code, 400)
        self.assertIn('error', response.data)
```

---

## üìä PERFORMANCE

### Database Optimization

```python
# ‚úÖ Sempre usar select_related para ForeignKey
campaigns = Campaign.objects.select_related('instance', 'tenant').all()

# ‚úÖ Sempre usar prefetch_related para ManyToMany e reverse ForeignKey
campaigns = Campaign.objects.prefetch_related('messages', 'contacts').all()

# ‚úÖ Usar only() quando s√≥ precisa de alguns campos
campaigns = Campaign.objects.only('id', 'name', 'status').all()

# ‚úÖ Usar defer() para excluir campos pesados
campaigns = Campaign.objects.defer('metadata').all()

# ‚úÖ Usar annotate para c√°lculos no banco
from django.db.models import Count, Avg

campaigns = Campaign.objects.annotate(
    message_count=Count('messages'),
    avg_response_time=Avg('campaign_contacts__response_time')
)

# ‚úÖ Usar bulk_create para inser√ß√µes em massa
contacts_to_create = [
    CampaignContact(campaign=campaign, contact=c)
    for c in contacts
]
CampaignContact.objects.bulk_create(contacts_to_create, batch_size=1000)

# ‚úÖ Usar update() para atualiza√ß√µes em massa (evita signals)
Campaign.objects.filter(status='draft', created_at__lt=old_date).update(
    status='cancelled'
)

# ‚úÖ Usar F() expressions para opera√ß√µes at√¥micas
from django.db.models import F
Campaign.objects.filter(id=campaign_id).update(
    sent_messages=F('sent_messages') + 1
)
```

### Caching Strategy

```python
# settings.py
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.redis.RedisCache',
        'LOCATION': 'redis://127.0.0.1:6379/1',
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        },
        'KEY_PREFIX': 'alrea',
        'TIMEOUT': 300,  # 5 minutos default
    }
}

# Uso em views
from django.core.cache import cache
from django.views.decorators.cache import cache_page

@cache_page(60 * 5)  # Cache por 5 minutos
def campaign_stats(request):
    # ...

# Uso manual
def get_tenant_campaign_limit(tenant_id):
    cache_key = f'tenant:{tenant_id}:campaign_limit'
    limit = cache.get(cache_key)
    
    if limit is None:
        tenant = Tenant.objects.get(id=tenant_id)
        limit = tenant.plan.max_campaigns
        cache.set(cache_key, limit, timeout=3600)  # 1 hora
    
    return limit

# Invalidar cache quando necess√°rio
def update_tenant_plan(tenant_id, new_plan):
    # ... atualizar plano ...
    cache.delete(f'tenant:{tenant_id}:campaign_limit')
```

---

## üîí SEGURAN√áA

### Multi-tenant Isolation

```python
# middleware.py - Sempre injetar tenant no request

class TenantMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
    
    def __call__(self, request):
        if request.user.is_authenticated:
            request.tenant = request.user.tenant
        return self.get_response(request)

# permissions.py - Sempre validar tenant

class IsTenantOwner(permissions.BasePermission):
    """Permite acesso apenas a objetos do pr√≥prio tenant"""
    
    def has_object_permission(self, request, view, obj):
        return obj.tenant == request.tenant

# views.py - Sempre filtrar por tenant

class CampaignViewSet(viewsets.ModelViewSet):
    permission_classes = [IsAuthenticated, IsTenantOwner]
    
    def get_queryset(self):
        # SEMPRE filtrar por tenant
        return Campaign.objects.filter(tenant=self.request.tenant)
    
    def perform_create(self, serializer):
        # SEMPRE injetar tenant na cria√ß√£o
        serializer.save(tenant=self.request.tenant, created_by=self.request.user)
```

### Input Validation

```python
# validators.py

from django.core.validators import RegexValidator

phone_validator = RegexValidator(
    regex=r'^\+?1?\d{9,15}$',
    message="N√∫mero de telefone deve estar no formato: '+999999999'. At√© 15 d√≠gitos permitidos."
)

# Sanitiza√ß√£o de dados
import bleach

def sanitize_html(text):
    """Remove HTML perigoso de texto"""
    allowed_tags = ['b', 'i', 'u', 'em', 'strong']
    return bleach.clean(text, tags=allowed_tags, strip=True)
```

---

## üìù LOGGING E MONITORING

```python
# settings.py

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'json': {
            '()': 'pythonjsonlogger.jsonlogger.JsonFormatter',
            'format': '%(asctime)s %(name)s %(levelname)s %(message)s'
        },
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'verbose',
        },
        'file': {
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': 'logs/django.log',
            'maxBytes': 1024 * 1024 * 10,  # 10MB
            'backupCount': 10,
            'formatter': 'json',
        },
    },
    'loggers': {
        'campaigns': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
            'propagate': False,
        },
    },
}

# Uso nos arquivos

import logging
logger = logging.getLogger('campaigns')

logger.info(
    "Campaign started",
    extra={
        'campaign_id': str(campaign.id),
        'tenant_id': str(tenant.id),
        'user_id': str(user.id),
        'total_contacts': campaign.total_contacts
    }
)
```

---

## ‚úÖ CHECKLIST DE CODE REVIEW

Antes de fazer Pull Request, verifique:

### Models
- [ ] UUID como PK
- [ ] tenant_id em todos os models de neg√≥cio
- [ ] Timestamps (created_at, updated_at)
- [ ] Choices para campos com valores finitos
- [ ] Help text descritivo
- [ ] Validators no model
- [ ] Properties para l√≥gica derivada
- [ ] __str__ √∫til
- [ ] Meta com ordering e constraints
- [ ] Indexes nos campos de busca

### Views/Serializers
- [ ] Permiss√µes configuradas
- [ ] Queryset filtra por tenant
- [ ] select_related / prefetch_related
- [ ] Valida√ß√µes customizadas
- [ ] Tratamento de erros
- [ ] Logging de a√ß√µes importantes

### Frontend
- [ ] Loading states
- [ ] Error handling
- [ ] Empty states
- [ ] Feedback visual
- [ ] Valida√ß√£o de formul√°rios
- [ ] TypeScript sem `any`
- [ ] Componentes reutiliz√°veis
- [ ] Acessibilidade (ARIA labels)

### Testes
- [ ] Testes de models
- [ ] Testes de API
- [ ] Testes de tasks
- [ ] Cobertura > 80%

### Seguran√ßa
- [ ] Input sanitization
- [ ] Multi-tenant isolation
- [ ] Rate limiting em endpoints cr√≠ticos
- [ ] CORS configurado corretamente

### Performance
- [ ] N+1 queries resolvidos
- [ ] Indexes criados
- [ ] Cache onde apropriado
- [ ] Pagina√ß√£o implementada

---

**√öltima Atualiza√ß√£o:** 2025-10-08  
**Vers√£o:** 1.0.0  
**Mantenedor:** ALREA Development Team

